%% -*- mode: erlang;erlang-indent-level: 4;indent-tabs-mode: nil -*-
%% ex: ts=4 sw=4 ft=erlang et
%% This is a sample rebar.conf file that shows examples of some of rebar's
%% options.

%% == Artifacts ==

%% Artifacts are files generated by other tools (or plugins) and whose
%% presence is necessary for a build to be considered successful
{artifacts, ["priv/mycode.so"]}.


%% == Erlang Compiler ==

%% Erlang files to compile before the rest. Rebar automatically compiles
%% parse_transforms and custom behaviours before anything other than the files
%% in this list.
{erl_first_files, ["src/mymib1.erl", "src/mymib2.erl"]}.

%% Erlang compiler options
{erl_opts, [no_debug_info,
            {i, "myinclude"},
            {platform_define,
             "(linux|solaris|freebsd|darwin)", 'HAVE_SENDFILE'},
            {platform_define, "(linux|freebsd)", 'BACKLOG', 128},
            {platform_define, "R13", 'old_inets'}]}.

{minimum_otp_vsn, "21.0"}.

%% MIB Options?
{mib_opts, []}.
%% SNMP mibs to compile first?
{mib_first_files, []}.

%% leex options
{xrl_opts, []}.
%% leex files to compile first
{xrl_first_files, []}.

%% yecc options
{yrl_opts, []}.
%% yecc files to compile first
{yrl_first_files, []}.

%% == Application Discovery ==

%% Extensions for discovering application resource files. Rebar3 discovers
%% applications by searching for these files. When building the application
%% information, rebar will use the first discovered files in the list.
%% This configuration is intended to let profiles compose with special app
%% files by prefixing extensions.
{application_resource_extensions, [
    ".app.src.script", ".app.src"
]}

%% == Common Test ==

%% {erl_opts, [...]}, but for CT runs
{ct_compile_opts, []}.
%% {erl_first_files, ...} but for CT runs
{ct_first_files, []}.
%% Same options as for ct:run_test(Opts)
{ct_opts, []}.


%% == Cover ==

%% Whether to enable coverage reporting where commands support cover. Default
%% is `false'
{cover_enabled, false}.

%% Modules to exclude from cover
{cover_excl_mods, []}.

%% Options to pass to cover provider
{cover_opts, [verbose]}.


%% == Dependencies ==

%% What dependencies we have, dependencies can be of 3 forms, an application
%% name as an atom, eg. mochiweb, a name and a version (from the .app file), or
%% an application name, a version and the SCM details on how to fetch it (SCM
%% type, location and revision).
%% Rebar3 currently supports git and hg
{deps, [
    app_name,         % latest version of package
    {rebar, "1.0.0"}, % version 1.0.0 of a package
    {rebar,           % git, main branch of app, explicit
     {git, "git://github.com/rebar/rebar.git", {branch, "main"}}},
    {rebar,           % git, over HTTPS
     {git, "https://github.com/rebar/rebar.git", {branch, "main"}}},
    {rebar,           % git, tag
     {git, "https://github.com/rebar/rebar.git", {tag, "1.0.0"}}},
    {rebar,           % git, specific reference/hash
     {git, "https://github.com/rebar/rebar.git", {ref, "7f73b8d6"}}},
    {rebar,           % mercurial is also supported
     {hg, "https://github.com/rebar/rebar.git", {tag, "1.0.0"}}},
    %% Alternative formats, backwards compatible declarations
    {rebar,           % default branch, will warn recommending explicit branch
     {git, "git://github.com/rebar/rebar.git"}},
    {rebar, "1.0.*",  % regex version check, ignored
     {git, "git://github.com/rebar/rebar.git"}},
    {rebar, "1.0.*",  % literal branch/ref/tag, will warn for explicit reference
     {git, "git://github.com/rebar/rebar.git", "Rev"}},
    {rebar, ".*",     % 'raw' dependency, argument ignored
     {git, "git://github.com/rebar/rebar.git", {branch, "main"}},
     [raw]}
]}.


%% == Dialyzer ==

{dialyzer, [
    {warnings, [underspecs, no_return]},
    {get_warnings, true},
    {plt_apps, top_level_deps}, % top_level_deps | all_deps
    {plt_extra_apps, []},
    {plt_location, local}, % local | "/my/file/name"
    {plt_prefix, "rebar3"},
    {base_plt_apps, [stdlib, kernel, crypto]},
    {base_plt_location, global}, % global | "/my/file/name"
    {base_plt_prefix, "rebar3"}
]}.


%% == Directories ==

%% directory for artifacts produced by rebar3
{base_dir, "_build"}.
%% directory in '<base_dir>/<profile>/' where deps go
{deps_dir, "lib"}.
%% where rebar3 operates from; defaults to the current working directory
{root_dir, "."}.
%% where checkout dependencies are to be located
{checkouts_dir, "_checkouts"}.
%% where, under <base_dir>/<profile> checkout dependencies are to be built
{checkouts_out_dir, "checkouts"}.
%% directory in '<base_dir>/<profile>/' where plugins go
{plugins_dir, "plugins"}.
%% directories where OTP applications for the project can be located
{project_app_dirs, ["apps/*", "lib/*", "."]}.
%% Directories where source files for an OTP application can be found
{src_dirs, ["src"]}.
%% Paths to miscellaneous Erlang files to compile for an app
%% without including them in its modules list
{extra_src_dirs, []}.
%% Path where custom rebar3 templates could be found
{template_dir, []}.

%% == EDoc ==

%% EDoc options, same as those passed to the edoc compiler
%% when called by hand.
{edoc_opts, []}.


%% == Escript ==

%% name of the main OTP application to boot
{escript_main_app, application}.
%% Name of the resulting escript executable
{escript_name, "application"}.
%% Wrapper type(s) for escript executable on windows
{escript_wrappers_windows, ["cmd","powershell"]}.
%% apps (other than main and deps) to be included
{escript_incl_apps, []}.
%% Executable escript lines
{escript_shebang, "#!/usr/bin/env escript\n"}.
{escript_comment, "%%\n"}.
{escript_emu_args, "%%! -escript main ~s -pa ~s/~s/ebin\n"}.


%% == EUnit ==

%% eunit:test(Tests)
{eunit_tests, [{application, rebar3}]}.
%% Options for eunit:test(Tests, Opts)
{eunit_opts, [verbose]}.
%% Additional compile options for eunit. erl_opts is also used
{eunit_compile_opts, [{d, some_define}]}.
%% {erl_first_files, ...} but for Eunit
{eunit_first_files, ["test/test_behaviour.erl"]}.


%% == Overrides ==

{overrides, [
    %% Add options to mydep's configurations for each element
    {add, mydep, [{erl_opts, []}]},
    %% replace mydep's configuration option
    {override, mydep, [{erl_opts, []}]},
    %% replace all dependencies' configuration options
    {override, [{erl_opts, []}]}
]}.

%% == Pre/Post Shell Hooks ==

%% Running shell commands before or after a given rebar3 command

{pre_hooks, [{clean, "./prepare_package_files.sh"},
             {"linux", compile, "c_src/build_linux.sh"},
             {compile, "escript generate_headers"},
             {compile, "escript check_headers"}]}.

{post_hooks, [{clean, "touch file1.out"},
              {"freebsd", compile, "c_src/freebsd_tweaks.sh"},
              {eunit, "touch file2.out"},
              {compile, "touch postcompile.out"}]}.

%% == Provider Hooks ==

%% Run a rebar3 command before or after another one.
%% Only clean, ct, compile, eunit, release, and tar can be hooked around

%% runs 'clean' before 'compile'
{provider_hooks, [{pre, [{compile, clean}]}]}.


%% == Releases ==

{relx, [{release, {my_release, "0.0.1"},
         [myapp]},

        {dev_mode, true},
        {include_erts, false},

        {extended_start_script, true}]}.

%% == Shell ==

%% apps to auto-boot with `rebar3 shell'; defaults to apps
%% specified in a `relx' tuple, if any.
{shell, [{apps, [app1, app2]}, {script_file, "shell.escript"}]}.

%% == xref ==

{xref_warnings, false}.

%% optional extra paths to include in xref:set_library_path/2.
%% specified relative location of rebar.config.
%% e.g. {xref_extra_paths,["../gtknode/src"]}
{xref_extra_paths,[]}.

%% xref checks to run
{xref_checks, [undefined_function_calls, undefined_functions,
               locals_not_used, exports_not_used,
               deprecated_function_calls, deprecated_functions]}.

%% Optional custom xref queries (xref manual has details) specified as
%%     {xref_queries, [{query_string(), expected_query_result()},...]}
%% The following for example removes all references to mod:*foo/4
%% functions from undefined external function calls as those are in a
%% generated module
{xref_queries,
 [{"(XC - UC) || (XU - X - B"
   " - (\"mod\":\".*foo\"/\"4\"))",[]}]}.

%% You might want to exclude certains functions or modules from your
%% rebar3 xref analysis.
%% You can do so with the following option, that takes as list items
%% one or more of a combination of:
%% * module(),
%% * {module(), function()},
%% * {module(), function(), arity()}
{xref_ignores, []}.

%% == alias ==

%% When you want a certain combination of operations to be done
%% as if you were using a rebar3 command. In the example below:
%% > rebar3 check
%%   (equivalent to rebar3 do xref, dialyzer)
%% or
%% > rebar3 test
%%   (equivalent to rebar3 do eunit, ct --suite=rebar_alias_SUITE, cover)

{alias, [{check, [xref, dialyzer]},
         {test, [eunit, {ct, "--suite=rebar_alias_SUITE"}, cover]}]}.
